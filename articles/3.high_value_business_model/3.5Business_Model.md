# 业务建模

![business_model.jpeg](https://s1.locimg.com/2024/06/12/dd2c914ba396b.jpeg)

我们在[人狼的诞生](https://jade-hub.com/#/articles/1.1)中讨论过一个问题：软件开发过程中最困难的部分是什么？

是编码实现？还是架构设计？其实都不是，**软件开发中最困难的部分是对概念模型的抽象！**

***能够有效的将复杂的业务逻辑通过清晰的方式，精简的表达出来才是最困难的部分！***

当产品经理通过各种方式获得了高价值的业务，并将其通过用户故事串联起来时，研发团队是否就可以直接进行开发了呢？显然不行！主要原因是计算机暂时还没发直接处理业务并生成代码(虽然AI以后有可能)，所以必须通过研发人员进行业务抽象，然后将其转化计算机能够识别的代码才能转化为软件。

这其中扮演者关键的角色就是业务建模，业务建模的产物就是业务模型，它是对业务知识的抽象、精简表达，为实现软件架构提供最基础的支撑依据！

那么，业务建模的思想是如何产生的呢？

## 模型的诞生

在软件行业发展的早期，堆、栈、链表树、图等与领域无关的模型，确实帮我们解决了从编译器、内存管理到数据库索引等大量的基础问题。因此，无数的成功案例让从业人员形成了一种习惯: 将问题转化为与具体领域天关的数据结构，即构造与具体领域无关的模型是软件研发的内在核心。

随着时间的发展，计算机软件从实验室的底层技术性基础系统，慢慢衍生到顶层业务系统，参与构建的人员也从单一的计算机从业人员发展到业务领域人员，那么团队中就会引入并不具有开发背景的业务方参与。这个时候，与领域无关的数据结构及其关联算法，由于业务方并不了解，在他们的头脑中也就无法直观地映射为业务的流程和功能。这种认知上的差异，会造成团队沟通的困难，从而破坏统一语言的形成，加剧知识传递的难度。

此时，面向对象设计类的语言和思想的出现，指导当时的技术人员从业务角度思考问题，设计更加贴合业务的模型和技术架构。这一思想的出现，为业务建模奠定了基础。

对于业务软件而言，从业务出发去构造与业务强相关的模型，将相关的业务流程与功能转化成模型的行为，就能避免开发人员与业务方的认知差异，是一种更好的选择，业务建模由此而来。

所以，**业务模型主要有三个用途：**
1. 通过模型承载业务知识，映射软件结构，当你理解了模型，你就基本上理解了软件架构和代码结构。
2. 以模型为基础，统一了团队语言，在讨论需求的时候，研发人员可以很明白需要改动的代码，并对风险和进度有了更好的评估。
3. 模型是业务支持的承载体，承载了纯粹的知识，同时模型比代码更加简洁，因而传递成本更低。

## 建模的难点

我们前面说到，**软件开发中最困难的部分是对概念模型的抽象！** 为什么会这么说呢？ 

### 首要难点是有效准确的定义业务问题

因为抽象的前提是要准确定义业务问题，通常来说，问题定义得准确，那么实现起来也不会复杂到哪里去。反之，如果没有搞清楚要解决什么问题，就可能需要各种奇技淫巧去弥补问题定义上的不足。

想要有效定义问题，就要从业务出发，首先尝试在业务中寻找简化问题的可能性，然后在技术中寻找对应的解决方案。业务建模就是这样一个过程。明确业务中的关键问题，使用易于实现的模型将业务问题表达出来，将隐藏在业务逻辑中的复杂度进行简化与精炼，并让所有干系人都接受你对业务问题的定义;

事实上，很多产品经理都不太会有效定义问题，这也是为什么有这么多“屎山”一样的产品了！

这里所说的定义业务问题，是指对业务问题的梳理和总结，明确对业务的影响及产出。所以不是让你说明自己做的是什么业务，而是要你去提炼总结它，并通过你所选用的业务建模方法中蕴含的逻辑框架去验证它。如果发现漏洞和不足，要及时提出，让人参与讨论。

### 次要难点是在特定架构下实现模型

我们在学习建模方法的时候，往往会不自觉地忽略架构对模型的影响。于是大概率会出现这样一种情况: ***学会了一种建模方法，却因为不知道怎么处理架构约束，而无法将其应用到实际工作中。***

就好像如果今天你去学习面向对象建模方法，那么很可能你为模型所编写的代码，仍然会是在与数据存储无关的单体架构下，练习各种继承与接口的用法。而一旦在工作中真正使用数据库、网络的访问开销，会把你的模型打散得七零八落。

正因为这两个困难，业务建模方法成了一种“所有人都在谈论它，但是没人知道具体怎么做;所有人都觉得其他人在使用它，于是只能声称自己也在用的东西”。

## 模型与软件实现关联

由于模型承载了业务，同时又为软件架构实现提供了依据，所以：
* 模型的好坏直接影响了软件的实现
* 模型的好坏直接影响了统一语言
* 模型的好坏直接影响了传递效率与成本

在业务模型的概念里，与业务概念对应的不仅仅是单个对象，而是通过关联关系连接的多组对象，表示业务概念，而一部分业务逻辑也只对这样的一组对象起效。但是在所有的关联关系中，聚合是最重要的一类。它表明了通过聚合关系连接在一起的对象，从概念上讲是一个整体。

此处可以举个例子


这显然简化了理解代码的难度。只要我们在概念上理解了模型，就会大致理解代码的实现方法与结构。同样，也简化了我们实现业务逻辑的难度。通过模型可以解说的业务逻辑，大致也知道如何使用“富含知识的模型”在代码中实现它。

### 修改模型就是修改代码

关联模型与软件实现，最终的目的是为了达到这样一种状态:***修改模型就是修改代码;修改代码就是修改模型。**

在知识消化中，提炼知识的重构是围绕模型展开的。如果对于模型的修改，无法直接映射到软件的实现上，那么凝练知识的重构循环就必须停下来，等待这个同步的过程。

如果不停下来等待，模型与软件间的割裂，就会将模型本身分裂为更接近业务的分析模型以及更接近实现的设计模型(Design Model)。这个时候，分析模型就会逐渐退化成纯粹的沟通需求的工具，而一旦脱离了实现的约束，分析模型会变得天马行空，不着边际。

### 贫血对象和充血模型

“**贫血对象模型**”(AnemicModel)是Thoughtworks首席科学家 Martin Fowler定义的一类模型，即: **对象仅仅对简单的数据进行封装，而关联关系和业务计算都散落在对象的范围之外**。这种方式实际上是在沿用过程式的风格组织逻辑，而没有发挥面向对象技术的优势。

与之相对的则是“**充血模型**”，也就是与某个概念相关的主要行为与逻辑，都被封装到了对应的领域对象中。“充血模型”也就是领域驱动设计中强调的“**富含知识的模型**"。

在领域驱动设计中，充血模型的代表是实体，他们拥有唯一标识符，且标识符在经历各种状态变更后仍能保持一致，对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。与实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。

所以，在业务模型中，我们应该关注那些富含知识的充血模型，他们真正代表了业务，代表了系统的实现。

## 建模的常见手法

### 领域驱动设计

### 事件驱动设计

