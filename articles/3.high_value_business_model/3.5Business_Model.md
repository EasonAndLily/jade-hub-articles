# 业务建模

![business_model.jpeg](https://s1.locimg.com/2024/06/12/dd2c914ba396b.jpeg)

我们在[人狼的诞生](https://jade-hub.com/#/articles/1.1)中讨论过一个问题：软件开发过程中最困难的部分是什么？

是编码实现？还是架构设计？其实都不是，**软件开发中最困难的部分是对概念模型的抽象！**

***能够有效的将复杂的业务逻辑通过清晰的方式，精简的表达出来才是最困难的部分！***

## 本质的困难

之所以这么说，因为建模必须直面下面两个根本困难： 

#### 1. 有效准确的定义业务问题

抽象的前提是准确定义业务问题。通常来说，如果问题定义得准确，那么实现起来也不会过于复杂。反之，如果没有搞清楚要解决什么问题，就可能需要各种奇技淫巧来弥补问题定义上的不足。

要有效定义问题，就必须从业务出发，首先尝试在业务中寻找简化问题的可能性，然后在技术中寻找对应的解决方案。业务建模正是这样一个过程。它通过明确业务中的关键问题，使用易于实现的模型将业务问题表达出来，将隐藏在业务逻辑中的复杂度进行简化和精炼，并让所有干系人都接受你对业务问题的定义。

事实上，很多产品经理并不擅长有效定义问题，这也是为什么有这么多“屎山”一样的产品存在的原因。

这里所说的定义业务问题，是指对业务问题的梳理和总结，明确其对业务的影响及产出。这并不是让你简单地说明自己做的是什么业务，而是要你提炼和总结它，并通过你所选用的业务建模方法中蕴含的逻辑框架去验证它。如果发现漏洞和不足，要及时提出，并让相关人员参与讨论。

### 2. 在特定架构下实现模型

我们在学习建模方法的时候，往往会不自觉地忽略架构对模型的影响。于是大概率会出现这样一种情况: ***学会了一种建模方法，却因为不知道怎么处理架构约束，而无法将其应用到实际工作中。***

就好像如果今天你去学习面向对象建模方法，那么很可能你为模型所编写的代码，仍然会是在与数据存储无关的单体架构下，练习各种继承与接口的用法。而一旦在工作中真正使用数据库、网络的访问开销，会把你的模型打散得七零八落。

正因为这两个困难，业务建模方法成了一种“所有人都在谈论它，但是没人知道具体怎么做;所有人都觉得其他人在使用它，于是只能声称自己也在用的东西”。

当产品经理通过各种方式获取了高价值的业务需求，并将其通过用户故事串联起来时，研发团队是否就可以直接开始开发了呢？显然不行！主要原因是，计算机目前还无法直接处理业务需求并生成代码（尽管未来的AI可能会实现这一点）。因此，必须通过研发人员对业务进行抽象，然后将其转化为计算机能够识别的代码，才能最终实现软件。

在这个过程中，业务建模扮演着关键角色。业务建模的产物是业务模型，它对业务知识进行抽象和精简表达，为实现软件架构提供了最基础的支撑依据。

那么，业务建模的思想是如何产生的呢？

## 模型的诞生

在软件行业发展的早期，堆、栈、链表、树、图等与领域无关的数据结构，确实帮助我们解决了从编译器、内存管理到数据库索引等大量基础问题。因此，无数成功案例让从业人员形成了一种习惯：**将问题转化为与具体领域无关的数据结构，即构造与具体领域无关的模型是软件研发的核心。**

随着时间的推移，计算机软件从实验室的底层技术系统逐渐扩展到顶层业务系统，参与构建的人员也从单一的计算机从业人员扩展到业务领域的专家。此时，团队中引入了不具备开发背景的业务方参与。由于业务方不了解与领域无关的数据结构及其关联算法，他们无法在头脑中直观地将这些结构映射为业务流程和功能。这种认知差异会导致团队沟通困难，破坏统一语言的形成，并加剧知识传递的难度。

在这种背景下，面向对象设计语言和思想的出现，指导技术人员从业务角度思考问题，设计更加贴合业务的模型和技术架构。这一思想的出现，为业务建模奠定了基础。

对于业务软件而言，从业务出发构建与业务高度相关的模型，将相关的业务流程和功能转化为模型，可以有效避免开发人员与业务方之间的认知差异。这是一种更好的选择，业务建模因此应运而生。

所以，**业务模型主要有三个用途：**
1. 通过模型承载业务知识，映射软件结构，当你理解了模型，你就基本上理解了软件架构和代码结构。
2. 以模型为基础，统一了团队语言，在讨论需求的时候，研发人员可以很明白需要改动的代码，并对风险和进度有了更好的评估。
3. 模型是业务支持的承载体，承载了纯粹的知识，同时模型比代码更加简洁，因而传递成本更低。

## 业务系统还是领域系统？

许多人对业务建模存在一些偏见，认为自己所做的系统根本没有建模的必要。他们认为，一个简单的三层架构（或MVC）就能解决问题，稍微复杂一点的系统上个微服务架构也就足够了。每个服务不过是CRUD操作，Spring的全家桶已经帮你做了所有的事情，直接使用就行了。那么，为什么还需要业务模型作为支撑呢？

关键原因在于，你所遇到的系统还不够复杂。该业务系统没有在组织中牵扯到多个部门和多个角色共同参与构建，所承载的知识也无需通过统一语言来传播。因此，使用业务建模在这种情况下可能显得“高射炮打麻雀——大材小用”。

那么，什么才是复杂的业务逻辑？到底什么才算复杂？

按照前面的章节中，Cynefin框架的解释是这样的：

> 复杂系统：代表可能有，也可能没有解决方案的系统，充满未知和不确定性。因果关系往往在事后才能感知，刚开始可能毫无头绪。应对方式是探索 - 感知 - 响应。在允许试错的前提下，先做小范围实验和尝试，等待某些规律和指导涌现出来后，再来认知和评估，然后响应。

这种复杂问题最直接的影响就是：其复杂程度已经超出了个人所能够理解、分析和解决的范围。我总结了三个针对“复杂性”的典型特征：
* 业务流程长
* 业务场景多
* 业务概念多

要解决复杂的问题，首要任务不是如何进行分析，而是引入更多的人，利用更多的大脑来共同解决问题。当从一个人变成多个人时，问题就随之而来：别人的思维方式和理解是否与我一致？他所理解的和我理解的一样吗？

正因为多人共同协作时会出现沟通和理解上的障碍，领域驱动设计（DDD）提出了一个关键思想：统一语言（Ubiquitous Language）。

统一语言的实现方式是通过领域专家与技术专家的通力合作，针对业务问题进行协作分析和设计，通过迭代式的探索、发现和碰撞来达成共识。

当你遇到复杂的系统时，以统一语言为核心，通过协作设计的方式，对业务问题进行分析和澄清的业务建模就显得非常必要了。

业务建模有多种方法：适用于领域系统的领域驱动设计（DDD），适用于业务系统的事件驱动设计（EDD）等。关键在于明确什么是领域系统，什么是业务系统。

**业务逻辑**：源自业务运营的逻辑，是领域中立且运营特定的，其复杂度来自于流程本身，关注的是如何盈利和成本结构（或者可以理解为对外体现为利润或现金，对内体现为成本和绩效承诺），常见于：合同、法务、会计、审计等。“业务逻辑的复杂度来自于流程本身，关注的是如何盈利和成本结构“，在现实中，其实更多的关注的是甲乙双方，基于某种具有权责关系的合作约定的过程凭证留存和追溯。

**领域逻辑**：源自问题域的逻辑，是运营中立而领域特定的，其复杂度来自于问题本身，关注的是如何解决问题，常见于：算法、计划、统计、优化等。

![domian-and-bussiness](https://img.chkaja.com/7892aef0e3224ba4.png)

举个例子，对于一个电商系统来说，如果你关注的是买卖双方的交易过程，那么这是一个业务系统，使用事件驱动设计（EDD）更为适合。而如果你关注的是基于用户行为分析的商品推荐能力，那么这是一个领域系统，使用领域驱动设计（DDD）更加适合。

在许多情况下，对于一个大型而复杂的系统，业务和领域是共存的。之所以要区分它们，是因为业务逻辑和领域逻辑具有明显不同的变化原因和变化频率。如果不理解这一点，可以想象一下电商系统中的折扣总额（业务）和促销活动（领域）。

这些建模方法共同作用，相辅相成，组成了完整的业务建模体系。

## 模型与软件实现关联

由于模型承载了业务，同时又为软件架构实现提供了依据，所以：
* 模型的好坏直接影响了软件的实现
* 模型的好坏直接影响了统一语言
* 模型的好坏直接影响了传递效率与成本

在业务模型的概念里，与业务概念对应的不仅仅是单个对象，而是通过关联关系连接的多组对象，表示业务概念，而一部分业务逻辑也只对这样的一组对象起效。但是在所有的关联关系中，聚合是最重要的一类。它表明了通过聚合关系连接在一起的对象，从概念上讲是一个整体。

此处我们使用用户角色权限的模型来举一个例子：

![user-role.jpg](https://tc-1303817403.cos.ap-chengdu.myqcloud.com/2024/06/16/666f002b46ba1.jpg)

上面的模型图虽然比较简单，但是如果想要看得懂，必须要了解下面聚合和组合的知识：
* **聚合(Aggregation)**：描述的是松散的关系，部分和整体的生命周期并不相关，部分的实例化过程在整体外部进行然后通过某种方式注入给整体。通常用空心的菱形和线段表示。
* **组合(Composition)**：描述的是紧密的关系，部分和整体是共存亡，部分的实例化在整体中进行。

根据聚合和组合的特点，我们可以很容易的推断出模型在实例化过程中的时序关系：被聚合的对象应该在主对象之前创建，被聚合的对象可以独立于主对象存在；被组合的对象应该在主对象后创建，且被组合的对象不能脱离主对象单独存在。

那么上面的用户角色权限的模型说明：User和Role之间是聚合关系，两者可以独立存在，Role应当在User之前创建；Role和Permission之间是组合关系，Permission不能独立于Role存在；

想想看，从业务角度来看，任何一个角色管理系统中，每个用户都是有Role的，Permission和User是通过Role来连接在一起的，不可能存在某个权限是没有角色对应的，这也从根本上杜绝了一些bug的产生。

这显然简化了理解代码的难度。只要我们在概念上理解了模型，就会大致理解代码的实现方法与结构。同样，也简化了我们实现业务逻辑的难度。通过模型可以解说的业务逻辑，大致也知道如何使用“富含知识的模型”在代码中实现它。

### 修改模型就是修改代码

关联模型与软件实现的最终目的是达到这样一种状态：***修改模型就是修改代码；修改代码就是修改模型。***

在知识消化过程中，知识的提炼和重构是围绕模型展开的。如果模型的修改无法直接映射到软件实现上，那么知识凝练的重构循环就必须停下来，等待这个同步过程。

如果不暂停等待，模型与软件之间的割裂将导致模型分裂为更接近业务的分析模型和更接近实现的设计模型（Design Model）。在这种情况下，分析模型会逐渐退化成纯粹的需求沟通工具。一旦脱离了实现的约束，分析模型可能会变得天马行空，不着边际。

### 贫血对象和充血模型

“**贫血对象模型**”（Anemic Model）是由Thoughtworks首席科学家Martin Fowler定义的一类模型，即：**对象仅仅对简单的数据进行封装，而关联关系和业务计算都散落在对象的范围之外**。这种方式实际上沿用了过程式的风格来组织逻辑，没有发挥面向对象技术的优势。

与之相对的是“**充血模型**”，即与某个概念相关的主要行为与逻辑都被封装到对应的领域对象中。“充血模型”也就是领域驱动设计（DDD）中强调的“**富含知识的模型**”。

在领域驱动设计中，充血模型的代表是实体。实体拥有唯一标识符，且标识符在经历各种状态变更后仍能保持一致。对于这些对象而言，重要的不是其属性，而是其延续性和标识。对象的延续性和标识会跨越甚至超出软件的生命周期。与实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。

因此，在业务模型中，我们应该关注那些富含知识的充血模型，它们真正代表了业务，代表了系统的实现。