# 高效能软件架构

![software-architecture.jpg](https://s1.locimg.com/2024/10/04/03cc426870ee1.jpg)

如何提高效能也成为近几年企业或者团队管理者的热门话题。在软件架构领域，如何设计一套合理的架构从而提升团队研发效能也是一个值得探讨的问题。

软件架构作为软件系统的基石，对于构建高效稳定的软件系统具有重要意义，一个好的软件架构能够确保系统的稳定性、可维护性和可扩展性，降低系统的风险和成本，从而极大提高软件研发效能；相反，一个设计有缺陷的软件架构，不仅让系统的扩展性变差，极大的增加项目的维护成本，让团队陷入挣扎的泥潭，拖累团队的效率。

那什么是架构呢？ IEEE给出了架构的定义：
> the fundamental organization of a system, embodied in its components, their relationships to each other and the environment, and the principles governing its design and evolution         --ANSI/IEEE

系统的基本组织，体现在系统的组件、组件间关系和环境关系，以及控制系统设计和发展的原则。

上面的定义听起来有些抽象，简单看来就是通过一系列的原则和实践，定义系统组件和组件之间、组件和环境之间的关系的基本构成。

而大师 Martin Fowler和Ralph Johnson对于架构的定义有着更加简洁的抽象：**重要并且难以改变的决策！**
> Software Architecture = Important and hard to change decisions   --Martin Fowler
>
> The software architecture is the important stuff ! Whatever it is !   --Ralph Johnson

***所以软件架构就是重要的东西，不论它是什么！***

下面我们就从效能的角度来看，架构对于效能的影响。

## 分层架构

分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构，比如计算机网络的7层架构，就是典型的分层架构。很多时候，如果你不知道要用什么架构，那就用它。

这种架构将软件分成N个层，每一层都有清晰的职责(角色和分工)，不需要知道其他层的细节，层与层之间通过接口通信，请求都是依次通过每个层进行处理，最终又依次返回。虽然没有明确约定，软件一定要分成多少层，但是三/四层的结构最常见。

![layer-architecture.jpg](https://s1.locimg.com/2024/10/04/f5dd71bf593c9.jpg)

* 表现层（presentation）： 用户展示界面，负责视觉和用户互动，主要是一些视图相关。
* 业务层（business）：实现业务逻辑，是系统的核心组件，代表的业务的核心流程和核心逻辑。
* 持久层（persistence）：提供数据增删改查支持，比如SQL语句就放在这一层。
* 存储层（database）：存储数据，主要是一些数据库。

从效能的角度来看，这种架构结构简单，容易理解和开发，不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构，同时每一层都可以独立测试，其他层的接口通过模拟解决。

然而，由于各层之间耦合性较强，一旦环境变化，需要代码调整或增加功能时，必须依次扩展每一层，通常比较麻烦和费时；同时，由于业务层没有通过模型进行设计，导致业务层内部服务之间耦合相当严重，各种业务逻辑纠缠在一起，最终形成一个膨胀层，严重阻塞了软件的可维护性，长期下去研发效能将逐渐降低。

### MVC

为了有效解决分层架构中业务逻辑层(Business Layer)业务关系耦合性强的问题，将业务逻辑层进一步拆分为两层，一层负责接受表现层的请求，封装和组装数据，控制表现层的展示，称之为控制器(Controller), 另一层负责领域逻辑，封装了核心业务模型，我们称之为模型(Model), 这就是MVC(Model View Controller)架构。

![mvc.jpg](https://s1.locimg.com/2024/10/04/fdd632c2e6068.jpg)

本质上来说，MVC架构是分层架构的衍生，对业务逻辑层进一步解耦，使得代码更加易于维护和优化。同时，通过Controller这一层，将视图和业务逻辑进行了解耦，将数据展示和数据生成放到了不同的模块中，易于维护和扩展。

## 六边形架构

随着微服务的兴起，领域驱动设计(DDD)成为微服务划分的主要指导思想，虽然DDD并不要求采用特定的架构风格，因为它是对架构中立的。你可以采用传统的三层式架构，也可以采用REST架构和事件驱动架构等。但是在《实现领域驱动设计》中，作者比较推崇事件驱动架构和六边形（Hexagonal）架构。

六边形架构的设计思想源于Alistair Cockburn在2005年提出的“六边形关系图”理论。在这个理论中，软件系统被视为一个六边形，其中有三组组件构成：**核心业务逻辑（Domain），输入和输出端口（Ports）以及适配器（Adapters）**。这些组件通过一系列接口进行交互，实现内部的业务逻辑，并通过端口和适配器与外部系统进行交互。

在六边形架构中，已经不存在分层的概念，所有组件都是平等的。这主要得益于软件抽象的好处，即各个组件的之间的交互完全通过接口完成，而不是具体的实现细节。正如Robert C. Martin所说：***抽象不应该依赖于细节，细节应该依赖于抽象。**

![hexagonal.jpeg](https://s1.locimg.com/2024/10/07/77a0d899c1edc.jpeg)

软件系统的真正价值在于提供业务功能，我们会将所有的业务功能分解为若干个业务用例，每一次业务用例都表示对软件系统的一次原子操作。软件系统中应该存在这样的组件，他们的作用即以业务用例为单位向外界暴露该系统的业务功能。在DDD中，这样的组件称为应用层（Application Layer）。

领域模型(Domain)位于应用程序的核心部分，外界与领域模型的交互都通过应用层完成，应用层是领域模型的直接客户。然而，应用层中不应该包含有业务逻辑，否则就造成了领域逻辑的泄漏，而应该是很薄的一层，主要起到协调的作用，它所做的只是将业务操作代理给我们的领域模型。同时，如果我们的业务操作有事务需求，那么对于事务的管理应该放在应用层上，因为事务也是以业务用例为单位的。

适配器(Adapters)是连接输入和输出端口与具体实现的桥梁。它们负责将外部世界的请求转换为适合核心业务逻辑处理的数据，并将结果适配为外部系统能够理解的形式。适配器可以是数据库、消息队列、外部服务库或任何其他与外部系统进行交互的方式。

从效能角度来看，六边形架构具有清晰的边界和职责，可以独立于外部接口进行测试和演进，这使得业务逻辑更加内聚到业务领域模型中，极大降低了与外部的耦合性，在以领域为团队职责划分的组织架构中，将领域知识内聚在团队内部，使得团队分工更加明确，业务更加清晰，效率极大提升。

## 洋葱架构

在六边形架构的基础上，2008年Jeffrey Palermo已经提出了具有“分层思想”的洋葱架构。所以，洋葱架构是六边形架构和分层架构的结合体。

洋葱架构是由多个同心层构成，圆圈代表不同的责任层,它们相互连接，并朝向代表领域的核心。一般来说，我们潜入得越深，就越接近于领域和业务规则;外圈代表机制，内圈代表核心领域逻辑。

![onion-architecture.webp](https://s1.locimg.com/2024/10/13/b9cba66af1313.webp)

洋葱架构是建立在一个领域模型上的，其中各层是通过接口连接的。其背后的思想是，在领域实体和业务规则构成架构的核心部分时，尽可能将外部依赖性保持在外。外层依赖于内层，而内层则对外圈一无所知。通常情况下，属于外圈的类、方法、变量和源代码依赖于内圈，但是反过来也一样, 所以基于控制反转（Inversion of Control，IoC）的原则。该架构并不关注底层技术或框架，而是关注实际的领域模型。

在继承六边形架构的优势上，洋葱架构进一步最小化了层与层之间的耦合，最大化了跨层垂直切面内的内聚，使得团队更加专注于领域模型，而不必过多地担心实现细节，从而将团队从各种细节纠缠中解脱出来，更多的聚焦于业务价值，从根本上提升了效能。

### 整洁架构

不管是六边形架构还是洋葱架构，对业务领域的划分是非常重要且关键的一环，可以被认为是“重要且难以改变的决策”，往往需要非常透彻的理解业务的领域专家和技术专家才能做到，本质上来说是相当困难的！

于是，Robert C. Martin提出的一种被称为“整洁”的软件设计架构，这种架构降低了洋葱架构的复杂度，将层仅仅分为三层：外部依赖层，适配器层和UserCase层，其中着重不同的是UserCase(用例层)，包含了各种实体(Entities), 实体和用例共同构成了业务逻辑。实际上，整洁架构可以理解为一种“折中架构”。

![clean-architecture.jpg](https://s1.locimg.com/2024/10/13/0dc1eab51c6e3.jpg)

相比洋葱架构而言，整洁架构强调依赖只能从外层指向内层，而洋葱架构则更侧重于依赖关系的方向性，即依赖向内指向领域模型。该架构从业务逻辑的角度降低了划分领域的复杂度和架构设计的难度，在基于控制反转的原则上，以干净、清晰、整洁为主要特色，提升了各层的可测试性，进而提升了团队对架构的理解和易于改变性，提升了整体研发效能。

## 事件驱动架构

在[《领域建模》](https://jade-hub.com/articles?articleId=3.4)中，我们了解到，随着业务系统的不断发展，业务逻辑的复杂度来自于流程本身，关注的是如何盈利和成本结构，在现实中，其实更多的关注的是甲乙双方，基于某种具有权责关系的合作约定的过程凭证留存和追溯。

比如对于一个电商系统来说，更关注的是买卖双方的交易过程，该过程中有很多关键性节点：商家上架产品并提供报价--> 客户基于报价采购下单 --> 商家客户签订买卖协议 --> 客户付款 --> 商品出库 --> 物流送货 --> 客户签收确认 --> 交易结束。在这个过程中，每个关键阶段都需要关键标的物进行追溯，需要对合作约定进行过程凭证留存和追溯。

这种复杂的业务流程本身就是分布式的异步架构，于是，基于“事件驱动的架构”被提出来，简单理解就是“就是通过事件进行通信的软件架构”，核心理念认为事件本身就是一种可以被追溯的实体，具有以下特性：
* 事件记录已经发生的事情。
* 事件捕获无法更改或删除的不可变事实。
* 无论服务在使用事件时是否应用任何逻辑，事件都会发生。
* 事件可以大规模无限期地持久保留，并且可以根据需要多次使用。

在大多数事件驱动架构中，通常存在下面几个组件：
* **生产者：** 可以产生事件的主体，通常位于事件流的上游。
* **消费者：** 可以接受事件并消费事件的主体，通常位于事件流的下游。
* **分发器：** 存储事件的队列，提供事件处理的路由，匹配事件和消费者的关系。
* **触发器：** 设定事件分发的时机和规则，触发事件进行分发。

![event-architection.png](https://s1.locimg.com/2024/10/13/015a4202eb816.png)

事件驱动架构天生适合于基于业务流的异步场景，对于通过职能划分的团队组织结构而言，降低了业务依赖对团队职责的依赖性，团队可以独立开发和部署各个服务，提升了研发效能。