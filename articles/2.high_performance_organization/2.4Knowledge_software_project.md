# 围绕知识构建软件工程

![knowledge-software-engineering.png](https://s1.locimg.com/2024/03/24/d64521af5e223.png)

**软件给人最大的误解是让人们觉得它是一款产品！**

**事实上，软件本身是载体，并不是真正的产品，真正的产品是包含在其中的知识。**

举例来说，腾讯视频是一款产品么？站在用户的角度，用户是不会关注腾讯视频这款软件的，用户关注的是腾讯视频提供的内容，内容才是真正的产品，任何能提供视频内容的软件都是载体，所以真正有价值的不是软件本身，而是软件承载的知识。所以，不管爱奇艺、优酷，还是土豆，只要是提供了用户喜欢的内容，用户自然就会使用该软件。

那么软件到底包含哪些知识呢？答案是有三类：业务知识，架构知识和运营知识。

软件中包含的最重要的知识就是业务知识，也就是我们所说的业务流程、组织架构、行业规则、领域知识等等。这些知识描述了软件是如何帮助客户解决某一类问题，或是一家企业是如何运营其业务的，或是以何种形式与用户互动等等。**作为产品的业务知识可以脱离软件存在，但是作为载体的软件却不能脱离其内在的知识存在**（技术上虽然可以，但是没必要存在）。

所以，这个世界上不存在哪一款软件创造了需求，在QQ和微信诞生以前，通信的需求一直存在；在移动支付诞生以前，货币化交易一直存在。软件使的现实世界的需求以更加高效的方式承载和表达了出来，与其花时间研究软件功能，不如沉下心来研究创造需求的人，组织和世界！

除去业务知识之外，软件中还包含关于“软件系统该如何实现”的知识，也就是我们所说的软件架构。架构定义了系统中组件的类型以及组件间交互的方式。架构有两个目的：**帮助我们理解系统现状，以及当有新需求出现时我们要如何实现它们。**

对于理解系统现状而言，架构知识是显式知识。它会通过不同的视图描述系统中具体的组件以及组件间的交互。对于应对新需求的变化，需要将需求分解到对应的组件中去，并严格依照组件间的交互方式完成业务逻辑。此时，架构的主要作用是作为系统需求功能拆分的指导，是以不可言说知识的形式在发挥作用。

软件中还存在运营知识，是指在软件产品从创建到推广、维护、迭代的全过程中所需的一系列知识和技能。运营知识涵盖主要涵盖三个方面：用户运营，产品运营和活动运营。运营知识可以帮助企业优化业务流程和管理方式，从而提高生产效率和降低成本。这可以确保企业在竞争激烈的市场中保持领先地位。

## 软件研发的过程是知识具象表达的过程
如果您对软件研发过程有所了解，相信对下面的工作流并不陌生：
![knowledge-flow.jpg](https://s1.locimg.com/2024/03/29/63f630e9c6207.jpg)

从大的阶段来看，这幅图反应的软件研发流程基本上可以分为三个阶段：产品设计，软件研发和部署运维阶段。

在产品设计阶段，产品经理或者业务分析师要通过市场研究来捕获市场中有价值的信息，然后将这些有价值的信息转化为产品的业务需求，再将业务需求通过业务建模等方式转化为产品的业务模型。业务模型是软件核心业务的抽象表达，描述了产品的价值主张，关键活动和关键资源，用来帮助企业所有人员理解产品的核心竞争力。在这个阶段，业务知识是最主要的知识，业务知识是从零散的市场信息通过业务分析转变为产品的价值模型，从零散变得规整，从无序变得有序，从现象到本质的蜕变。该阶段的重点是获取和分析有价值的知识，价值是这个阶段追求的重点。

在软件研发阶段，将业务模型通过领域建模等方式形成软件的领域模型，领域模型结合软件设计范式转化为软件的架构设计图。业务需求通过敏捷迭代的方式进行拆分，拆分的业务需求通过用户故事来表达出来，用户故事可以形成验收标准，进而指导测试用例的编写；在编码阶段，通过BDD+TDD的研发模式，将用户故事逐步转化为软件功能，进而将迭代需求逐步实现。在这个阶段中，业务知识和架构知识相辅相成，共同促进，知识从领域模型通过一系列的活动和过程转变为软件功能，形态发生了重要变化。在该阶段，追求的应当是知识形态转化的质量，避免在这个转化过程中，知识被丢失和误解(可能bug就是这么产生的吧)。

在部署运维阶段，我们将通过持续集成，持续部署的方式，将软件功能呈现在用户面前。在这个阶段，运营和运维知识将是最主要的知识，这类知识通常比较明确，具体。该阶段知识通过规范的流程，标准的步骤，将软件推向市场，追求的是更快的速度。

整个流程强调了从市场信息到业务模型，再到软件功能，最后到市场部署的知识转化和价值创造过程。软件研发的过程，可以看做是知识的具象表达的过程。

## 不同种类的知识

在实际的工作过程中，从知识管理的角度，可以将知识可以分为三类：显性知识(explicit knowledge)，隐性知识(implicit knowledge)和不可言说知识(tacit knowledge)。

![knowledge-classification.jpg](https://s1.locimg.com/2024/03/30/84bd926d37229.jpg)

显性知识是可以被明确表达、记录、传播和共享的知识。它通常是结构化的，可以通过文字、数字、图表或其他形式来表达。例如，书籍、手册、数据库、科学公式、程序代码和操作流程等都是显性知识的载体。显性知识的特点是易于传递和复制，因此在组织中的共享和传播相对容易。

隐性知识是指尚未被明确表达出来，但是有潜力转化为显性知识的知识。它可能是个人或组织内部的一些经验、技能或洞察，尚未被完全意识到或者尚未被充分地文档化和形式化。隐性知识通常需要通过观察、实践或个人交流来获取。隐性知识只是一种尚未被记录下来的显性知识，是没有记录下来的事实。要将隐性知识转化为显性知识，唯一需要做的步骤就是记录它。

由于显性知识易于共享和传播，我们在软件研发过程中，应当尽量将隐形知识显性化出来，比如在业务设计阶段，我们通过业务建模将零散的业务知识显性表达了出来，在软件研发阶段，我们通过软件模型，架构设计，用户故事拆分等手段也将软件架构知识显性表达了出来。

不可言说的知识是一种难以通过语言表达或书面形式传递的知识。它是个人的经验、直觉、洞察力和技能的总和，通常是在长时间的实践、尝试和错误中积累起来的。这种知识与个人的认知过程、价值观、感觉和信念紧密相关，因此它是高度个人化的，并且与特定的情境和背景相关。

### 不可言说知识的价值

通常，不可言说的知识在软件工程中包括：

* **技能和手艺**：比如码农的编码的能力(BDD和TDD)，架构师的模型设计和软件架构设计能力，产品经理的市场分析能力等
* **直觉和直观判断**：比如产品经理对市场的敏锐嗅觉，测试工程师的探索性测试能力等
* **个人经验**：比如产品经理的用户调研，运维工程师踩过的坑等

不可言说的知识的传递通常依赖于个人之间的互动、共同工作、社会化过程和模仿学习，很难通过语言或其他的形式传播。例如，徒弟通过观察和模仿师傅的工作来学习某种手艺，而不仅仅是通过听讲或阅读说明书。

以软件开发为例，虽然像架构设计这样的设计概念可以通过书本学习，但想要真正掌握和精通却需要在实际过程中不断练习和应用。架构师需要在不同的项目和问题中使用这些设计范式，通过实际解决问题来深化理解。在这个过程中，他们不仅在学习如何使用这些范式，还在学习何时使用它们，以及如何在不同的环境和需求下调整用法。这些都是不可言说知识。

不可言说的知识也叫做**部落知识**，不可言说知识使得团队成员能够在没有明确指导的情况下高效协作。它帮助员工理解“我们是如何做事的”，这不仅仅是关于工作流程，更关乎于团队的价值观、信仰和期望。这种知识的共享和传播，促进了团队成员之间的信任和理解，加强了团队凝聚力。例如，在一个软件开发团队中，不可言说的知识可能包括特定的编码实践、项目管理的非正式流程、代码审查的潜规则，甚至是如何有效地与特定同事沟通的技巧。这些知识通常不在任何手册中，但对于新成员快速融入团队、提高工作效率和质量至关重要。

不可言说的知识对于组织和个人的创新和竞争力至关重要，也是冰山下的主体，因为它包含了无法轻易复制的深层次的理解和能力。然而，由于其难以捉摸和传递的特性，管理和利用不可言说的知识也是知识管理中的一个挑战。

### 不可言说知识的传递

**当代知识管理理论认为，社会化活动（Socialization）是传递不可言说知识的不二法门。**

不可言说知识通过共同活动进行交流，而不是书面或口头指令。比如在同一工作环境中，通过个体之间的互动完成不可言说知识的交换。学徒与导师一起工作，通过观察、模仿和实践来学习手工艺。在职培训也采用同样的原则。获取不可言说知识的关键是分享思维的过程，而不单单是消费最终的结果。

社会化活动最常见的形式是启动 - 反馈循环（kickoff-feedback cycle）。在启动阶段（Kick off） 时传递知识，在反馈（feedback）时检查知识是否被吸收并且转化成为实际的产出物。反馈中还要包含针对思维过程的反馈，或是知识消费者对思维过程的自省。

比如对于软件架构，一个最常见的错误是，架构师通常只会提供架构文档，以说明当前架构的现状，但很少为架构提供教程或使用手册。也就缺乏针对在不同场景下，如何应用架构中的概念解决问题的指引。缺乏训练法，架构中的不可言说知识就无法持续稳定地传播。这是很多架构腐化或是无法落地的根因。

在极限编程中，通常有一种方式叫做结对编程(Pair Programing), 通常结对的双方是老带新模式，以TDD的方式，经验丰富的前辈来写测试，将业务需求转化为测试，新手在前辈写测试的过程中不断的学习和观察来理解前辈的知识，然后由新手来写实现，前辈在新手实现的过程中，手把手来指导。这种社会化的模式将前辈不可言说的知识，传递给了新手，高效且高质量。

![pair-programming-social.jpeg](https://s1.locimg.com/2024/03/30/90f00b1ae3cc5.jpeg)

### 转化为知识过程

所谓知识过程，就是从知识管理的角度理解我们的工作，将我们的工作看作产生、传递、应用、消费知识的过程。由于不可言说知识的重要性，将任何工作转化为知识过程的关键，就是识别其中关键的不可言说知识，围绕不可言说知识的传递构造流程。

所以，对于高效的软件研发流程来说，想要让不可言说的知识顺畅的流转起来，必须要通过敏捷活动来支持！

![agile-activity.jpg](https://s1.locimg.com/2024/03/30/4bcf5e6d485a9.jpg)

## 认知行为模型

那我们怎么才能评估知识传递是否高效呢？关键就是知识传递和消费的效率。而知识在传递和消费的过程中，会在知识的消费者身上产生不同的认知模式。通过认知行为模式，我们可以进一步理解知识传递和消费的效率。

所谓认知模式，就是指人利用知识进行决策时，采取的行为模式。我们可以使用 Cynefin 框架理解不同知识消费和传递中产生的不同认知行为模式。

Cynefin 框架是戴维·斯诺登（David J. Snowden）在 1999 年围绕知识管理和组织战略开发的一个框架。Cynefin 框架原本是一种解决问题的工具，它可以帮助我们将各种情况归入由因果关系定义的五个“领域”。根据 2020 版 Cynefin 框架的定义，这五个领域分别是：**清晰（Clear）、庞杂（Complicated）、复杂（Complex）、混乱（Chaotic）和困惑（Aporetic/Confused）**。利用这五个领域，可以帮助我们更准确地评估情况，并做出适当的反应。

![Cynefin.jpg](https://pic.ziyuan.wang/user/guest/2024/03/Cynefin_941142915144a.jpg)

### 清晰（Clear）模式

这个领域以前被称为“简单”领域，它是指那些因果关系明确、可预测的情境。在这个领域中，正确的答案是已知的，问题可以通过应用最佳实践来解决。

决策过程通常是**感知（Sense）--> 分类（Categorize）--> 响应（Respond）**，即先感知情境，然后将其分类，并采取相应的行动。

举个医院里面的例子，如果你不感觉肚子不舒服，但是你不知道是挂什么科时，你需要去医院的问诊平台，负责接待的小姐姐在明确你的问题之后，基本上能迅速做出分类，并告知你是去挂什么科。

在这个过程中，对于问题的定义是已知的，解决方案是已知的，问题与解决方案的对应关系也是已知的。因而在认知上无负担，是认知水平最高的行为模式。所以清晰模式也叫“已知的已知”，此时如何决策是不容置疑的，因为各方都有共识。

在软件工程中，同样存在着这种模式，比如运营同学处理客诉问题，先要感知客户的诉求，然后迅速做出分类，最后针对分类做出响应。在这个过程中，知识应当是及其高效和明确的。

从知识分类的角度来看，在清晰模式下，**消费的知识是显式知识和已经充分掌握了的不可言说知识。**

### 庞杂（Complicated）模式

这种模式又叫专家模式，与清晰模式不同，在这个领域中，因果关系存在但不是显而易见的，需要专业知识或分析来理解。问题可以通过分析或咨询专家来解决，通常有多个可能的解决方案。

决策过程是**感知（Sense）--> 分析（Analyze）--> 响应（Respond）**，即通过分析来理解情境，然后采取行动。

对于某一个问题，首先感知它是什么问题，然后通过分析寻找可能的解决方案，并使用这个解决方案进行响应。比如你去医院，医生会通过各种检查感知你实际的状态，但并不能根据这些检查结果直接确定治疗方案。毕竟不同的疾病可能有相似的病症。医生需要通过分析具体是什么病因，并综合你的状态、过敏史等情况，才能确定治疗方案（响应）。

在软件工程中，架构的设计是属于专家模式，架构师通常需要感知软件的市场需求，业务变化和容量，结合现有系统资源和限制进行分析，然后才能设计出合适的软件架构。

在这个过程中，问题是已知的，解决方案是已知的多种选择，问题与解决方案的对应关系是未知的。庞杂模式与清晰模式非常类似，唯一的不同在于对于解决方案的寻找，也就是分析这一行为，这依赖于专业知识与能力，是典型的不可言说知识。这也是庞杂模式效率低于清晰模式的根因。

清晰与庞杂模式也被称作有序模式，是知识在消费和应用中产生的认知行为模式。庞杂模式比起清晰模式具有更大的认知负载，因而认知效率是低于清晰模式的。

### 复杂（Complex）模式

无论清晰模式还是庞杂模式，在开始响应之前，我们至少明确知道存在一个正确答案。然而，在复杂模式（Complex）下，正确答案是无法提前预知的，只能通过反思理解真正的问题和解决方案是什么，无论在前期多么的努力，都无法提前感知。

这个领域的特点是因果关系是可知的，但仅在事后才能被理解。在这里，没有固定的解决方案，需要通过实验和迭代来探索。决策过程是**探测（Probe）--> 感知（Sense）--> 响应（Respond）**，即尝试小规模的干预，观察其效果，然后根据学到的知识采取行动。

举个常见的例子，新药或者新的诊疗方法的研发属于复杂模式，在该模式下，必须要通过反复的实验，观察每次实验的结果和数据，经过不断的分析和对比，最终归纳出一套有效的诊疗方法。

在软件工程中，推荐算法的开发，需要通过实验来找到最佳解决方案，开发者可能需要尝试不同的算法和参数，然后通过用户反馈和行为数据来评估哪种方法最有效。

复杂模式的认知负载远远高于前面介绍的两种模式。首要原因在于其中问题的本质和解决方案都不是一开始就清晰可见的。在这种模式下，我们不能仅依赖于预设的规则或经验，而是必须不断地探索和适应，这本身就是一个学习过程。复杂模式是不可言说知识在传递和学习时，主要依据的一个认知行为模式。本质上是一种社会化的学习活动。

大家思考一下，软件开发中习以为常的Debuger属于那种模式呢？ 答案是复杂模式，在Debuger之前，你通常并不知道问题的根因是什么，所以你必须不断的通过断点调试来寻找根因，这也是为什么Debuger是属于非常低效的一种行为模式，在软件研发中并不推荐的原因！所以，正确的姿势应该是使用TDD的研发模式来替代Debuger，研发效率会提升一大截！

### 混乱（Chaotic）和困惑（Aporetic/Confused）模式

在混乱模式中，没有明显的因果关系，情境是不可预测和紧急的。在这种情况下，需要立即采取行动以防止事态恶化。决策过程是**行动（Act）--> 感知（Sense）--> 响应（Respond）**，即先采取行动以稳定情境，然后评估结果，并据此调整行动方案。

某种程度上说，这是个反模式，因而混乱模式不是基于知识的反应，而是应激式的反应。例如突发的系统崩溃或者是系统突然被黑客攻击，这种情况下，会让你感觉非常不安，所以必须先做点是什么事情来防止事态恶化，比如先快速重启服务，然后再分析造成事件的原因。

困惑模式是Cynefin 框架的新增领域，它代表了那些混淆不清或者我们不知道属于哪个领域的情境。在这种情况下，决策者可能需要暂停，反思，收集更多信息，或者重新审视问题，以便能够将其归类到其他四个领域中的一个。这个领域鼓励我们承认自己的不确定性和困惑，并采取措施来解决这种状态。

处在混乱和困惑模式时我们不能进行任何有效处理，是最低的认知水平，更是最低效的行为。

### 向有序模式演进

![cynefin-changed.jpg](https://pic.ziyuan.wang/user/guest/2024/03/cynefin-changed_9dc22837f2865.jpg)

对于组织而言，清晰（Clear）模式和庞杂（Complicated）模式的行为应该占据日常工作的绝大部分，他们被称作有序的认知模式，复杂（Complex）模式 和 混乱（Chaotic）模式会占据日常工作的一部分比例，他们被称作是无序的认知模式，过多的无序认知行为会带来低效的，低质量和高成本。

庞杂（Complicated）模式的行为我们通常需要引入领域专家和社会化的活动来传递知识，形成老带新的体系，并且逐渐将庞杂领域的知识固化到清晰模式，进一步提升效率。

复杂（Complex）模式的行为更多的是探索和反馈，所以在项目中应该提高其反馈的频率(本质上敏捷核心就是这样)，快速实验，快速分析，快速验证，尽量保证每次实验范围小，内容单一。

混乱（Chaotic）模式的行为更多的是突发事件引起，所以应该提前预想和演练，比如模拟服务宕机回复，将宕机后的反应步骤固化下来，变成清晰模式的行为。